// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontRight           motor         13              
// frontLeft            motor         12              
// backRight            motor         17              
// backLeft             motor         16              
// Gyro                 inertial      11              
// dr4b                 motor         3               
// Controller1          controller                    
// LE                   encoder       C, D            
// convey               motor         19              
// fourBar2             motor         1               
// twoBar               motor         10              
// tilter               motor         4               
// DistanceBack         distance      2               
// RotationTilter       rotation      5               
// DistanceFront        distance      21              
// vision_sensor        vision        7               
// middleLeft           motor         14              
// middleRight          motor         15              
// flywheel             motor         18              
// DigitalOutH          digital_out   H               
// Optical              optical       9               
// Distance             distance      8               
// Bumper               bumper        A               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontRight           motor         13              
// frontLeft            motor         12              
// backRight            motor         17              
// backLeft             motor         16              
// Gyro                 inertial      11              
// dr4b                 motor         3               
// Controller1          controller                    
// LE                   encoder       C, D            
// convey               motor         19              
// fourBar2             motor         1               
// twoBar               motor         10              
// tilter               motor         4               
// DistanceBack         distance      2               
// RotationTilter       rotation      5               
// DistanceFront        distance      21              
// vision_sensor        vision        7               
// middleLeft           motor         14              
// middleRight          motor         15              
// flywheel             motor         18              
// DigitalOutH          digital_out   H               
// Optical              optical       9               
// Distance             distance      8               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontRight           motor         13              
// frontLeft            motor         12              
// backRight            motor         17              
// backLeft             motor         16              
// Gyro                 inertial      11              
// dr4b                 motor         3               
// Controller1          controller                    
// LE                   encoder       C, D            
// convey               motor         19              
// fourBar2             motor         1               
// twoBar               motor         10              
// tilter               motor         4               
// DistanceBack         distance      2               
// RotationTilter       rotation      5               
// DistanceFront        distance      21              
// vision_sensor        vision        7               
// middleLeft           motor         14              
// middleRight          motor         15              
// backRot              rotation      20              
// flywheel             motor         18              
// DigitalOutH          digital_out   H               
// Optical              optical       9               
// Distance             distance      8               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontRight           motor         13              
// frontLeft            motor         12              
// backRight            motor         17              
// backLeft             motor         16              
// Gyro                 inertial      11              
// dr4b                 motor         3               
// Controller1          controller                    
// LE                   encoder       C, D            
// convey               motor         19              
// fourBar2             motor         1               
// twoBar               motor         10              
// tilter               motor         4               
// DistanceBack         distance      2               
// RotationTilter       rotation      5               
// DistanceFront        distance      21              
// vision_sensor        vision        7               
// middleLeft           motor         14              
// middleRight          motor         15              
// rightRot             rotation      6               
// backRot              rotation      20              
// flywheel             motor         18              
// DigitalOutH          digital_out   H               
// Optical              optical       9               
// Distance             distance      8               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontRight           motor         13              
// frontLeft            motor         12              
// backRight            motor         17              
// backLeft             motor         16              
// Gyro                 inertial      11              
// dr4b                 motor         3               
// Controller1          controller                    
// LE                   encoder       C, D            
// convey               motor         19              
// fourBar2             motor         1               
// twoBar               motor         10              
// tilter               motor         4               
// DistanceBack         distance      2               
// RotationTilter       rotation      5               
// DistanceFront        distance      21              
// vision_sensor        vision        7               
// middleLeft           motor         14              
// middleRight          motor         15              
// rightRot             rotation      6               
// backRot              rotation      20              
// flywheel             motor         18              
// DigitalOutH          digital_out   H               
// DigitalOutA          digital_out   A               
// Optical              optical       9               
// Distance             distance      8               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontRight           motor         13              
// frontLeft            motor         12              
// backRight            motor         17              
// backLeft             motor         16              
// Gyro                 inertial      11              
// dr4b                 motor         3               
// Controller1          controller                    
// LE                   encoder       C, D            
// convey               motor         19              
// fourBar2             motor         1               
// twoBar               motor         10              
// tilter               motor         4               
// DistanceBack         distance      2               
// RotationTilter       rotation      5               
// DistanceFront        distance      21              
// vision_sensor        vision        7               
// middleLeft           motor         14              
// middleRight          motor         15              
// rightRot             rotation      6               
// backRot              rotation      20              
// flywheel             motor         18              
// DigitalOutG          digital_out   G               
// DigitalOutH          digital_out   H               
// DigitalOutA          digital_out   A               
// Optical              optical       9               
// Distance             distance      8               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontRight           motor         13              
// frontLeft            motor         12              
// backRight            motor         17              
// backLeft             motor         16              
// Gyro                 inertial      11              
// dr4b                 motor         3               
// Controller1          controller                    
// LE                   encoder       C, D            
// convey               motor         19              
// fourBar2             motor         1               
// twoBar               motor         10              
// tilter               motor         4               
// DistanceBack         distance      2               
// RotationTilter       rotation      5               
// DistanceFront        distance      21              
// vision_sensor        vision        7               
// middleLeft           motor         14              
// middleRight          motor         15              
// rightRot             rotation      6               
// backRot              rotation      20              
// flywheel             motor         18              
// DigitalOutG          digital_out   G               
// DigitalOutH          digital_out   H               
// DigitalOutA          digital_out   A               
// Optical              optical       9               
// Distance             distance      8               
// ---- END VEXCODE CONFIGURED DEVICES ----
#include "vex.h"
#include "odom.h"
#include "driver.h"
#include "iostream"


using namespace vex;
using namespace std;

// A global instance of competition
competition Competition;

extern odom* pOdom;

// define your global instances of motors and other devices here

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the V5 has been powered on and        */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/


//variables
double fourBarPos = 0;
double twoBarPos = 0;


void pre_auton(void) {    
  // Initializing Robot Configuration. DO NOT REMOVE!
  
  vexcodeInit();
  Gyro.calibrate();
  while(Gyro.isCalibrating()) {
    wait(1, msec);
  }
  Optical.brightness(75);
  Optical.setLight(ledState::on);
  wait(2, sec);
  //wait(2, sec);
  Brain.Screen.print("Gyro calibrated");
  Brain.Screen.newLine();
  
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

///////////////////////////////////////////////////AUTON FUNCTIONS
void pickUp(double d, double pos, double cap) {
  tilter.setVelocity(100,percent);
  tilter.spinFor(fwd, pos, degrees);
  tilter.setStopping(hold);
  tilter.stop();
  odom::moveForwardPID(d, cap);
  while (!backLeft.isDone()) {
    wait(5, msec);
  }
}

void pickUpMogoD(bool tBar, bool fBar,  double d, double pos, double cap, int t1, int t2) {
  /*
  KEY: 
  ======> sys = true ---> fourBar
  ======> sys = false ---> twoBar
  */
  double dist = 0;
  if(DistanceFront.isObjectDetected()) {
    dist = DistanceFront.objectDistance(inches) + 3;
  } else {
    dist = d;
  }
    frontLeft.setTimeout(t1, sec);
    frontRight.setTimeout(t1, sec);
    backLeft.setTimeout(t1, sec);
    backRight.setTimeout(t1, sec);
    if (tBar) {
      twoBar.setTimeout(t2, sec);
      twoBar.startRotateFor(fwd, pos, degrees);
    } else if (fBar) {
      dr4b.setTimeout(t2, sec);
      twoBar.startRotateFor(fwd, pos, degrees);
    }
    odom::moveForwardPID(dist, cap);
    if (tBar) {
      twoBar.stop();
    } else if (fBar) {
      dr4b.stop();
    }
  
  
}

void pickUpMogoT(bool tBar, bool fBar, double d, double pos, double cap, int t1, int t2) {
  /*
  KEY: 
  ======> sys = true ---> fourBar
  ======> sys = false ---> twoBar
  */
  double dist = 0;
  if(DistanceBack.isObjectDetected()) {
    dist = -DistanceBack.objectDistance(inches);
    Brain.Screen.print("**********************TRUE");
    Brain.Screen.newLine();
  } else {
    dist = -d;
    Brain.Screen.print("*********************FALSE");
    Brain.Screen.newLine();
  }
    frontLeft.setTimeout(t1, sec);
    frontRight.setTimeout(t1, sec);
    backLeft.setTimeout(t1, sec);
    backRight.setTimeout(t1, sec);
    if (tBar) {
      twoBar.setTimeout(t2, sec);
      twoBar.startRotateFor(fwd, d, degrees);
    } else if (fBar) {
      dr4b.setTimeout(t2, sec);
      twoBar.startRotateFor(fwd, d, degrees);
    }
    odom::moveForwardPID(dist, cap);
    if (tBar) {
      twoBar.stop();
    } else if (fBar) {
      dr4b.stop();
    }
  
}

void moveTwoBar(double pos, int t, bool f) {
  //////////////MOGO = 288
  //////////////GROUND = 249
  //////////////STARTING = 358
  tilter.setStopping(hold);
  tilter.setTimeout(t, sec);
  tilter.setVelocity(75, percent);
  double rot = RotationTilter.angle();
 //while(abs(pos - rot) > 3) {
   while ((f?pos-rot:rot-pos) >3) {
    rot = RotationTilter.angle();
    if(f) {
      tilter.spin(fwd);
    } else {
      tilter.spin(reverse);
    }
    Brain.Screen.print(rot);
    Brain.Screen.newLine();
    cout << "Rotation: " << rot << "\n ";
    wait(1, msec);
  }
  tilter.stop();
  /*
  tilter.setVelocity(100,percent);
  tilter.spinFor(fwd, pos, degrees);
  tilter.setStopping(hold);
  tilter.stop();*/
}

void rawTwoBar(double pos, int t) {
  tilter.setStopping(hold);
  tilter.setTimeout(t, sec);
  tilter.setVelocity(100,percent);
  tilter.spinFor(fwd, pos, degrees);
  tilter.stop();
}



void activateLatch(double pos, int t) {
  /*
  latch.setTimeout(t, msec);
  latch.spinFor(vex::forward, pos, degrees);
  latch.setStopping(hold);
  latch.stop();*/
}

void pneuLatch() {
  //DigitalOutC.set(false);
}

void releaseLatch() {
  //DigitalOutC.set(true);
}

void moveFourBar(double pos, int t) {
  dr4b.setTimeout(t, sec);
  dr4b.setVelocity(100,percent);
  dr4b.spinFor(fwd, pos, degrees);
  dr4b.setStopping(hold);
  dr4b.stop();
}

void moveForwardAndFourBar(double d, double fbar, double cap, int t) {
  dr4b.setTimeout(t, sec);
  dr4b.setVelocity(100, percent);
  dr4b.startRotateFor(fwd, fbar, deg);
  odom::moveForwardPID(d, cap);
  dr4b.setStopping(hold);
  dr4b.stop();

  //while(!backLeft.isDone() || !frontLeft.isDone() || !frontRight.isDone() || !backRight.isDone()) {
    //wait(1, msec);
  //}
  Brain.Screen.print("MOTORS STOPPED");
}

void moveForwardAndTwoBar(double d, double tbar, double cap) {
  twoBar.setVelocity(100, percent);
  twoBar.startRotateFor(fwd, tbar, deg);
  odom::moveForwardPID(d, cap);

  while(!backLeft.isDone()) {
    wait(5, msec);
  }
}

void moveForwardFourBarTimer(double d, double fbar, int t, double cap) {
  frontLeft.setTimeout(t, sec);
  frontRight.setTimeout(t, sec);
  backLeft.setTimeout(t, sec);;
  backRight.setTimeout(t, sec);
  dr4b.setTimeout(6, sec);
  dr4b.setVelocity(100, percent);
  dr4b.startRotateFor(fwd, fbar, deg);
  dr4b.setStopping(hold);
  dr4b.stop();
  odom::moveForwardPID(d, cap);
}

void moveForwardConveyer(double d, double c, double t, double cap) {
  frontLeft.setTimeout(t, sec);
  frontRight.setTimeout(t, sec);
  backLeft.setTimeout(t, sec);
  backRight.setTimeout(t, sec);
  convey.setVelocity(100, percent);
  convey.startRotateFor(fwd, c, deg);
  odom::moveForwardPID(d, cap);
  convey.stop();

}

void moveForwardConveyerFourBar(double d,double fbar, double c, double t1, double t2,  double cap) {
  frontLeft.setTimeout(t1, sec);
  frontRight.setTimeout(t1, sec);
  backLeft.setTimeout(t1, sec);;
  backRight.setTimeout(t1, sec);
  dr4b.setStopping(hold);
  dr4b.setTimeout(6, sec);
  dr4b.setVelocity(100, percent);
  dr4b.startRotateFor(fwd, fbar, deg);
  convey.setVelocity(100, percent);
  convey.startRotateFor(fwd,c , deg);
  odom::moveForwardPID(d, cap);
  dr4b.stop();
  convey.stop();
}

void align(int c) {
  /*KEY:
    RED = 0
    BLUE = 1
  */
  int centerFOV = 195;
  int offsetX = 25;
  if (c == 0) {
    vision_sensor.takeSnapshot(vision_sensor__GOAL_RED);
  } else if (c == 1) {
    vision_sensor.takeSnapshot(vision_sensor__GOAL_BLUE);
  }
  
  while(vision_sensor.largestObject.centerX > centerFOV + offsetX || vision_sensor.largestObject.centerX < centerFOV - offsetX){  
    if (c == 0) {
      vision_sensor.takeSnapshot(vision_sensor__GOAL_RED);
    } else if (c == 1) {
      vision_sensor.takeSnapshot(vision_sensor__GOAL_BLUE);
    }

    if(vision_sensor.largestObject.centerX > centerFOV + offsetX){
      // eventually change to turnTo PID movement
      frontRight.spin(vex::forward, -20, vex::rpm);
      frontLeft.spin(vex::forward, 20, vex::rpm);
      middleRight.spin(vex::forward, -20, vex::rpm);
      middleLeft.spin(vex::forward, 20, vex::rpm);
      backRight.spin(vex::forward, -20, vex::rpm);
      backLeft.spin(vex::forward, 20, vex::rpm);
    } else if(vision_sensor.largestObject.centerX < centerFOV - offsetX){
      // eventually change to turnTo PID movement
      frontRight.spin(vex::forward, 20, vex::rpm);
      frontLeft.spin(vex::forward, -20, vex::rpm);
      middleRight.spin(vex::forward, 20, vex::rpm);
      middleLeft.spin(vex::forward, -20, vex::rpm);
      backRight.spin(vex::forward, 20, vex::rpm);
      backLeft.spin(vex::forward, -20, vex::rpm);
    } else {
      break;
    }
  }
  frontRight.stop();
  frontLeft.stop(); 
  backRight.stop(); 
  backLeft.stop();
}

void moveSpinner(double deg) {
  convey.setVelocity(60, percent);
  convey.rotateFor(vex::reverse, deg, degrees);
}

void moveShooter(double deg) {
  convey.setVelocity(100, percent);
  convey.rotateFor(vex::reverse, deg, degrees);
}

void startShooter(double deg) {
  flywheel.spin(vex::reverse, deg, vex::percent);
}

void rotateSpinnerOptical(double col, double t) {
  // if col = 1 --> color is blue
  // if col = 0 --> color is red
  // t sets the timeout
  convey.setPosition(0, degrees);
  frontLeft.setStopping(hold);
  frontRight.setStopping(hold);
  middleLeft.setStopping(hold);
  middleRight.setStopping(hold);
  backLeft.setStopping(hold);
  backRight.setStopping(hold);
  convey.setTimeout(t, seconds);
  //Optical.setLightPower(75, percent);
  bool spinning = true; 
  if (col == 0) {
    while (Optical.color() != red && spinning) {
      convey.spin(vex::forward, 20, percent);
      spinning = convey.isSpinning();
      wait(1, msec);
      if (convey.position(degrees) > 1000) {
        break;
      }
    }
    convey.stop(); 
  } else if (col == 1) {
    while (Optical.color() != blue && spinning) {
      convey.spin(vex::forward, 20, percent);
      spinning = convey.isSpinning();
      wait(1, msec);
      if (convey.position(degrees) > 1000) {
        break;
      }
    }
    
    convey.stop();
  }

  frontLeft.setStopping(coast);
  frontRight.setStopping(coast);
  middleLeft.setStopping(coast);
  middleRight.setStopping(coast);
  backLeft.setStopping(coast);
  backRight.setStopping(coast);
}

void brakeHold() {
  frontLeft.setStopping(hold);
  frontRight.setStopping(hold);
  middleLeft.setStopping(hold);
  middleRight.setStopping(hold);
  backLeft.setStopping(hold);
  backRight.setStopping(hold);
}

void brakeCoast() {
  frontLeft.setStopping(coast);
  frontRight.setStopping(coast);
  middleLeft.setStopping(coast);
  middleRight.setStopping(coast);
  backLeft.setStopping(coast);
  backRight.setStopping(coast);
}

void expand() {
  DigitalOutH.set(true);
}

void autonomous(void) {
  pOdom = new odom();
  vex::thread positionTrackingThread(odom::positionTracking); // Define thread for Position Tracking Method

  frontRight.setPosition(0, degrees);
  frontLeft.setPosition(0, degrees);
  middleRight.setPosition(0, degrees);
  middleLeft.setPosition(0, degrees);
  backLeft.setPosition(0, degrees);
  backRight.setPosition(0, degrees);
  
  // SPINNER
  //wait(1, sec);
  startShooter(54);
  //odom::moveForwardPID(-1.2, 600);//-3
  odom::moveForwardPIDDistance(500);
  wait(5, msec);
  //rotateSpinnerOptical(0, 3);
  moveSpinner(-750);
  wait(5, msec);
  odom::moveForwardPID(10, 400);
  wait(5, msec);

  // SPINNER
  odom::turnTo(45);
  wait(5, msec);
  moveForwardConveyer(21, 57000, 5, 400);
  wait(5, msec);
  odom::turnTo(177);
  wait(5, msec);
  //odom::moveForwardPID(-11.45, 600); // -12
  odom::moveForwardPIDDistance(550);
  wait(5, msec);
  //rotateSpinnerOptical(0, 3);
  moveSpinner(-750);
  wait(5, msec);

  // SHOOT 3 DISCS
  odom::moveForwardPID(12, 550);
  wait(5, msec);
  odom::turnTo(86);
  wait(5, msec);
  moveForwardConveyer(54, 57000, 5, 450);
  wait(5, msec);
  odom::turnTo(100);
  moveShooter(4000);
  //wait(5, msec);

  // COLLECT 3 DISCS
  odom::turnTo(177);
  wait(5, msec);
  moveForwardConveyer(38, 9000000, 5, 200);
  wait(5, msec);
  moveForwardConveyer(-38, 9000000, 5, 300);
  wait(5, msec);

  //SHOOT 3 DISCS
  odom::turnTo(98);
  wait(5,msec);
  moveShooter(4000);
  wait(5,msec);

  // COLLECT 3 DISCS
  startShooter(55);
  odom::turnTo(90);
  wait(5, msec);
  odom::moveForwardPID(-50, 450);
  wait(5, msec);
  odom::turnTo(135);
  wait(5, msec);
  moveForwardConveyer(67, 50000, 10, 450);
  convey.setVelocity(100, percent);
  convey.rotateFor(fwd, 4000, deg);
  wait(5, msec);
  
  // SHOOT 3 DISCS
  odom::turnTo(40);
  wait(5, msec);
  moveShooter(4000);
  wait(5, msec);
  
  // COLLECT 3 DISCS
  startShooter(54);
  odom::moveForwardPID(5.5, 300);
  wait(5, msec);
  odom::turnTo(90);
  wait(5, msec);
  moveForwardConveyer(40, 50000, 10, 200);
  convey.setVelocity(100, percent);
  convey.rotateFor(fwd, 4000, deg);
  wait(5, msec);

  // SHOOT 3 DISCS
  odom::reverseTurn(350);
  wait(5, msec);
  moveShooter(4000);
  wait(5, msec);

  // SPINNER 
  odom::reverseTurn(359);
  wait(5, msec);
  odom::moveForwardPID(-55, 450);
  wait(5, msec);
  odom::reverseTurn(270);
  wait(5, msec);
 
  // SPINNER
  //odom::moveForwardPID(-10, 550);
  odom::moveForwardPIDDistance(550);
  wait(5, msec);
  //rotateSpinnerOptical(0, 3);
  moveSpinner(-750);
  wait(5, msec);
  odom::moveForwardPID(10, 250);
  wait(5, msec);

  // SPINNER
  odom::turnTo(215);
  wait(5, msec);
  moveForwardConveyer(21, 57000, 5, 300);
  wait(5, msec);
  odom::turnTo(357);
  wait(5, msec);
  odom::moveForwardPIDDistance(550);
  //odom::moveForwardPID(-9, 350);
  wait(5, msec);
  //rotateSpinnerOptical(0, 3);
  moveSpinner(-750);
  wait(5, msec);

  // SHOOT 3 DISCS
  //startShooter(58);
  odom::moveForwardPID(12, 550);
  wait(5, msec);
  /*wait(5, msec);
  odom::turnTo(273);
  wait(5, msec);
  moveForwardConveyer(48, 57000, 5, 450);
  wait(5, msec);
  moveShooter(4000);
  wait(5, msec);
  odom::turnTo(268);
  wait(5, msec);
  odom::moveForwardPID(-55, 450);
  wait(5, msec);*/
  odom::turnTo(315);
  wait(5, msec);
  expand();



  // COLLECT 3 DISCS
  /*
  odom::turnTo(357);
  wait(5, msec);
  moveForwardConveyer(38, 9000000, 5, 250);
  wait(5, msec);
  moveForwardConveyer(-38, 9000000, 5, 250);
  wait(5, msec);

  //SHOOT 3 DISCS
  odom::turnTo(280);
  wait(5,msec);
  moveShooter(4000);
  wait(5,msec);

  // COLLECT 3 DISCS
  startShooter(53);
  odom::turnTo(270);
  wait(5, msec);
  odom::moveForwardPID(-52, 450);
  wait(5, msec);
  odom::turnTo(315);
  wait(5, msec);
  moveForwardConveyer(70, 50000, 10, 400);
  convey.setVelocity(100, percent);
  convey.rotateFor(fwd, 2500, deg);
  wait(5, msec);
  
  // SHOOT 3 DISCS
  odom::turnTo(220);
  wait(5, msec);
  moveShooter(4000);
  wait(5, msec);
  
  // COLLECT 3 DISCS
  startShooter(58);
  odom::moveForwardPID(6, 300);
  wait(5, msec);
  odom::turnTo(270);
  wait(5, msec);
  moveForwardConveyer(40, 50000, 10, 200);
  wait(5, msec);

  // SHOOT 3 DISCS
  odom::reverseTurn(350);
  wait(5, msec);
  moveShooter(4000);
  wait(5, msec);

  // SPINNER 
  odom::reverseTurn(179);
  wait(5, msec);
  odom::moveForwardPID(-60, 450);*/

  

while (1){
    //Insert move to functions and other functions over here
    
    //odom::moveForwardPID(24, 80);
    this_thread::sleep_for(10); //Wait for 10 Seconds, Updates x,y Every 10 Seconds
    //odom::turnTo(90);
  
  }


  

  // ..........................................................................
  // Insert autonomous user code here.
  // ..........................................................................
  
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/


  

/*
void fourBarFunction(){
  if (Controller1.ButtonR1.pressing()) {
    dr4b.spin(vex::forward, 100, vex::percent);
  } else if (Controller1.ButtonR2.pressing()){
    dr4b.spin(vex::reverse, 100, vex::percent);
  } else {
    dr4b.setStopping(brakeType::hold);
    dr4b.stop();
  }
}

void conveyorFunction() {
  if (Controller1.ButtonRight.pressing()) {
    conveyor.spin(vex::forward, 50, vex::percent); //75
  } else if (Controller1.ButtonLeft.pressing()) {
    conveyor.spin(vex::reverse, 50, vex::percent);
  } else {
    conveyor.setStopping(coast);
    conveyor.stop();
  }
}

void latchFunction() {
  if (Controller1.ButtonL1.pressing()) twoBar.spin(vex::forward, 100, vex::percent);
  else if (Controller1.ButtonL2.pressing()) twoBar.spin(vex::reverse, 100, vex::percent);
  else {
   twoBar.setStopping(hold);
   twoBar.stop(); 
  }


}

void latchActivation() {
  latch.spinFor(fwd, 100, degrees);
}

void latchRelease() {
  latch.spinFor(fwd, -100, degrees);
}


void clamp(){
  if (Controller1.ButtonX.pressing()) latch.spin(vex::reverse, 100, vex::percent);
  else if (Controller1.ButtonB.pressing()) latch.spin(vex::forward, 100, vex::percent);
  else {
    latch.setStopping(hold);
    latch.stop();
  }
}

////ONE STICK CONTROL
void oneStick()
{
  // Assigns  joystick axis values to variables 
  int axis3val = Controller1.Axis3.value();
  int axis4val = Controller1.Axis4.value();
  int  LV = 0;
  int  RV = 0;
  // Turning movement velocity declaration 
  int turnvel = 0;
  // Forward/backwards movement velocity declaration 
  int latvel = 0;
  // Threshold to provide for driver joystick error (sensitivity)
  int threshold = 10;

  //States that if the value of the joystick is greater than the threshold, 
  //set the velocity equal to the latvel variable
  if(abs(axis4val) > threshold)

    latvel = axis4val;
  // If the joystick val is less than 10, then don't take the value 
  else

    latvel = 0;
  // Same logic as above 
  if(abs(axis3val) > threshold)

    turnvel = axis3val;

  else

    turnvel = 0;
  // Allows for movement using axis vals 

  // If right side movement is needed, LV is greater and vice versa

  // If straight movement is needed the turnvel will be 0 so both velocities are the 
  // same 
  LV = turnvel + latvel;
  RV = turnvel - latvel;
  // Ignore the next 2 lines. Used for testing of Odometry 
  //O.update();

  //printf("%f,%f\n",O.posX,O.posY);
  //printf("%f,%f\n",LE.position(turns),RE.position(turns));

  // Gives move command to motors based on velocities from the axis vals on joystick

  backLeft.spin(vex::forward,LV,percent);
  backRight.spin(vex::forward,RV,percent);
  frontLeft.spin(vex::forward,LV,percent);
  frontRight.spin(vex::forward,RV,percent);

  
}

void holdRobot() {
  double l = Controller1.Axis3.position(vex::percent);  //Axis 3 controls forward + backward
    //int lateral = Controller1.Axis4.position(vex::percent);       //Axis 4 controls strafe left + strafe right
  double r = Controller1.Axis1.position(vex::percent);    //Axis 1 controls turning

  frontRight.setStopping(hold);
  frontLeft.setStopping(hold);
  backRight.setStopping(hold);
  backLeft.setStopping(hold);
  frontRight.spin(vex::forward, l - r, vex::percent); 
  frontLeft.spin(vex::forward, l + r, vex::percent);
  backRight.spin(vex::forward, l - r, vex::percent);
  backLeft.spin(vex::forward, l + r, vex::percent);
  
}
*/

/*
int Xpressed = 0;

bool alatch = false;
void flagA() {
  alatch = true;
}

int Upressed = 0;
bool ahold = false;

void flagB() {
  ahold = true;
}*/


void usercontrol(void) {
//Replace Cap and Floor Values with Actual Measured Values {Placer Holders Kept for Now}
  //pOdom = new odom();
  //vex::thread positionTrackingThread(odom::positionTracking); // Define thread for Position Tracking Method
  // User control code here, inside the loop

  //Controller1.ButtonX.pressed(flagA);
  //Controller1.ButtonUp.pressed(flagB);

  driver::robotDrive();
  

  

    //wait(20, msec); // Sleep the task for a short amount of time to
                    // prevent wasted resources.
  
}



//
// Main will set up the competition functions and callbacks.
//
int main() {
  // Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

   

  // Run the pre-autonomous function.
  pre_auton();

  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }
}